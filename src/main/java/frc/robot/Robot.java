/*-----------------------------------------------------------*/
/* LongMetal Robotics 2019. MIT Commons Licence              */
/* A clean slate to start writing code for Major Tom         */
/*   as well as to teach the basics of Git and GitHub.       */
/*                                                           */
/* ----------                                                */
/*                                                           */
/* Anything marked with [vc] means that this is a            */
/*   Visual Studio Code feature (these features may be       */
/*   available in other IDEs, but we develop in VSCode,      */
/*   and these are available by default.                     */
/*                                                           */
/* ----------                                                */
/*                                                           */
/* This program is hard coded for curvature drive but it is  */ 
/*   easy to change                                          */
/*                                                           */
/* ----------                                                */
/*                                                           */
/* ## ALWAYS REMEMBER TO CHANGE kCOMMIT TO KEEP TRACK OF     */
/* ## THE DEPLOYED CODE                                      */
/* ##                                                        */
/* ##                                                        */
/*                                                           */
/* ##                                                        */
/* ##                                                        */
/*                                                           */
/*-----------------------------------------------------------*/

package frc.robot;

/* ASCII art for easy navigation in [vc] minimap. ASCII art
 *   generated by patorjk.com (font: 4Max)
 */



/*  Import                                    */
/*  88 8b    d8 88""Yb  dP"Yb  88""Yb 888888  */
/*  88 88b  d88 88__dP dP   Yb 88__dP   88    */
/*  88 88YbdP88 88"""  Yb   dP 88"Yb    88    */
/*  88 88 YY 88 88      YbodP  88  Yb   88    */
/*                                            */

// Import Needed Classes
	// [vc] Hover over a class to learn more about it

// Classes required for *driving*
import edu.wpi.first.wpilibj.TimedRobot;
	/* TimedRobot is the 'skeleton' for the robot code.
	 * This runs certain code based on the time in the match. */
import edu.wpi.first.wpilibj.Joystick;
	/* Joystick allows us to get input from the drivers.
	 * Joystick can interact with gamepads, as well. */

import edu.wpi.first.wpilibj.SpeedControllerGroup;
	// Allows multiple speed controllers to be grouped together
	// (see lines 155, 162, 165)

import edu.wpi.first.wpilibj.drive.DifferentialDrive;
	// Allows for controlling drive trains such as
	// KOP, tank drive, or West Coast.

// Spark MAXs are used for drive motors, so import the classes for those.
import com.revrobotics.CANSparkMax;
	// The main class to control Spark MAXs over CAN.
import com.revrobotics.CANSparkMax.IdleMode;
	// Allows us to define whether the motors brake (bad)
	// or coast when the speed is set to 0.
import com.revrobotics.CANSparkMaxLowLevel.MotorType;
	// This is an important class that tells the Spark MAXs
	// whether to try to drive the motors as brushed
	// or brushless (there's a big difference).



public class Robot extends TimedRobot {
	/* Robot is the class that contains our code.
	 * It inherits all methods from TimedRobot and can
	 * @Override them to provide our own functionality. */



	/*  Declare                                               */
	/*  8888b.  888888  dP""b8 88        db    88""Yb 888888  */
 	/*   8I  Yb 88__   dP   `" 88       dPYb   88__dP 88__    */
 	/*   8I  dY 88""   Yb      88  .o  dP__Yb  88"Yb  88""    */
	/*  8888Y"  888888  YboodP 88ood8 dP""""Yb 88  Yb 888888  */
	/*                                                        */

	// These declarations create the objects required throughout the rest of the program but don't 

	// Create objects necessary to drive the robot
	private DifferentialDrive driveTrain;

	// Declare controllers
	private Joystick driveStickLeft;
	private Joystick driveStickRight;



	/*  Constants                                                           */
	/*   dP""b8  dP"Yb  88b 88 .dP"Y8 888888    db    88b 88 888888 .dP"Y8  */
	/*  dP   `" dP   Yb 88Yb88 `Ybo."   88     dPYb   88Yb88   88   `Ybo."  */
	/*  Yb      Yb   dP 88 Y88 o.`Y8b   88    dP__Yb  88 Y88   88   o.`Y8b  */
	/*   YboodP  YbodP  88  Y8 8bodP'   88   dP""""Yb 88  Y8   88   8bodP'  */
	/*                                                                      */

	// Create the constants used later.
	final double kMAX_SPEED_MULT = 0.5;
	/* The maximum speed for the robot:
	 * The value sent to the speed controllers is multiplied by this, therefore limiting it */

	final String kCOMMIT = "null";
	/* The current commit this code is on.
	 * Find on GitHub (top of repo>Latest commit)
	 *   or GitHub Desktop (History>(top commit)>-o-)
	 * [IMPORTANT]: UPDATE AFTER EVERY COMMIT
	 */



	/*  Robot Init                                                    */
	/*  88""Yb  dP"Yb  88""Yb  dP"Yb  888888     88 88b 88 88 888888  */
	/*  88__dP dP   Yb 88__dP dP   Yb   88       88 88Yb88 88   88    */
	/*  88"Yb  Yb   dP 88""Yb Yb   dP   88       88 88 Y88 88   88    */
	/*  88  Yb  YbodP  88oodP  YbodP    88       88 88  Y8 88   88    */
	/*                                                                */

	// Override inherited method
	@Override
	public void robotInit() {
		/* This method is run once each time the code is started
		 * Eg. the robot was turned on, the RIO was reset, etc.
		 * [vc] Hover over the method name to learn more about it */

		System.out.println("Commit " + kCOMMIT + " or later");



		/*  Drive Train     */
		/*  8888b.  888888  */
		/*   8I  Yb   88    */
		/*   8I  dY   88    */
		/*  8888Y"    88    */
		/*                  */

		// Create objects and/or assign values for the drivetrain

		// Left Motors
		CANSparkMax m_rearLeft = new CANSparkMax(1, MotorType.kBrushless); //left front
		m_rearLeft.setIdleMode(IdleMode.kCoast);
		CANSparkMax m_frontLeft = new CANSparkMax(2, MotorType.kBrushless); //left back
		m_frontLeft.setIdleMode(IdleMode.kCoast);
		SpeedControllerGroup leftmotors = new SpeedControllerGroup(m_rearLeft, m_frontLeft);

		// Right Motors
		CANSparkMax m_rearRight = new CANSparkMax(3, MotorType.kBrushless); //right front
		m_rearRight.setIdleMode(IdleMode.kCoast);
		CANSparkMax m_frontRight = new CANSparkMax(4, MotorType.kBrushless); //right back
		m_frontRight.setIdleMode(IdleMode.kCoast);
		SpeedControllerGroup rightmotors = new SpeedControllerGroup(m_rearRight, m_frontRight);

		// Full drivetrain
		driveTrain = new DifferentialDrive(leftmotors, rightmotors);
		


		/*  Controls                      */
		/*   dP""b8 888888 88""Yb 88      */
		/*  dP   `"   88   88__dP 88      */
		/*  Yb        88   88"Yb  88  .o  */
		/*   YboodP   88   88  Yb 88ood8  */
		/*                                */

		driveStickLeft = new Joystick(0);
		driveStickRight = new Joystick(1);
		System.out.println("Left joystick should be in port 1.");	// Port 1 corresponds to 0 in the code

	}



	/*  Teleop Periodic                                           */
	/*  888888 888888 88     888888     88""Yb 888888 88""Yb      */
	/*    88   88__   88     88__       88__dP 88__   88__dP      */
	/*    88   88""   88  .o 88""   .o. 88"""  88""   88"Yb  .o.  */
	/*    88   888888 88ood8 888888 `"' 88     888888 88  Yb `"'  */
	/*                                                            */

	@Override
	public void teleopPeriodic() {
		// This method is run frequently (10ms?) during teleop.

		double modifierX = ((0.7 * driveStickLeft.getThrottle() - 1.05) / 2);	// Allow modification of maximum speed to an extent
		double modifierZ = (driveStickRight.getThrottle() - 1) * -0.25;			// Allow modification of maximum turning speed

		double driveX = driveStickLeft.getY() * modifierX * kMAX_SPEED_MULT;	// Compute driving speed
		double driveZ = driveStickRight.getZ() * modifierZ;						// Compute turning speed

		driveTrain.curvatureDrive(driveX, driveZ, true);	// Drive
	}
}